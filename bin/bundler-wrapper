#!/usr/bin/env ruby
# 
# Copyright (c) 2015 Solano Labs All Rights Reserved
#

module BundlerWrapper
  class BundlerWrapper
    MAX_RERUNS = 5

    def self.invoke(argv)
      env = ENV.to_hash.dup

      reruns = 0

      while reruns < MAX_RERUNS do
        status, rerun = run_bundler(env, argv)
        if status == 0 || !rerun then
          exit(status)
        end
        $stdout.puts "NOTICE: automatically retrying bundle command..."
        reruns += 1
      end
      exit(255)
    end

    # This function is from ruby and covered by its copyright
    def self.popen_run(cmd, opts, child_io, parent_io)
      pid = spawn(*cmd, opts)
      wait_thr = Process.detach(pid)
      child_io.each {|io| io.close }
      result = [*parent_io, wait_thr]
      if defined? yield
        begin
          return yield(*result)
        ensure
          parent_io.each{|io| io.close unless io.closed?}
          x = wait_thr.join
        end
      end
      result
    end

    # This function is from ruby and covered by its copyright
    def self.popen2e(*cmd, &block)
      if Hash === cmd.last
        opts = cmd.pop.dup
      else
        opts = {}
      end

      in_r, in_w = IO.pipe
      opts[:in] = in_r
      in_w.sync = true

      out_r, out_w = IO.pipe
      opts[[:out, :err]] = out_w
      popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &block)
    end

    ERROR_MESSAGES = [
      'Gem::RemoteFetcher::FetchError:',
      'Errno::ETIMEDOUT:',
      'Connection timed out - connect(2)'
    ]

    def self.run_bundler(env, argv)
      path = ENV['PATH'] || "/bin:/usr/bin:/sbin:/usr/sbin"
      path = path.split(':')
      bundle = nil
      path.each do |p|
        if File.exists?(File.join(p, 'bundle')) then
          bundle = File.join(p, 'bundle')
          break
        end
      end

      if argv.length < 1 || argv[0] != 'install' then
        env.each_pair do |k, v|
          ENV[k.to_s] = v.to_s
        end
        argv.unshift(bundle)
        Kernel.exec(*argv)
        Kernel.exit!(255)
      end

      status, rerun = 255, false
      status = BundlerWrapper.popen2e(bundle, *argv) do |i, oe, t|
        i.close

        oe.each_line do |line|
          $stdout.puts line
          $stdout.flush
          ERROR_MESSAGES.each do |error_message|
            if line.include?(error_message) then
              rerun = true
            end
          end
        end

        oe.close
        t.value
      end

      return [status.exitstatus, rerun]
    end
  end
end

BundlerWrapper::BundlerWrapper.invoke(ARGV)
